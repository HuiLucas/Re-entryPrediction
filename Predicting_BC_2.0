import numpy as np

import matplotlib
from matplotlib import pyplot as plt

# Load tudatpy modules
from tudatpy.interface import spice
from tudatpy import numerical_simulation
from tudatpy.numerical_simulation import environment
from tudatpy.numerical_simulation import environment_setup, propagation_setup
from tudatpy.astro import element_conversion, time_conversion
from tudatpy import constants
from tudatpy.util import result2array
from tudatpy.astro.time_conversion import DateTime
import datetime
# import inspect


# ## Configuration
# NAIF's `SPICE` kernels are first loaded, so that the position of various bodies such as the Earth can be make known to `tudatpy`.
# 
# Then, the start and end simulation epochs are setups. In this case, the start epoch is set to `0`, corresponding to the 1st of January 2000. The times should be specified in seconds since J2000.
# Please refer to the API documentation of the `time_conversion module` [here](https://tudatpy.readthedocs.io/en/latest/time_conversion.html) for more information on this.


# Load spice kernels
spice.load_standard_kernels()

# Set simulation start and end epochs
start_date = DateTime(2022, 9, 6, 0, 27, 00.970272)
simulation_start_epoch = start_date.epoch()
simulation_end_epoch   = DateTime(2022, 10, 6).epoch()


# ## Environment setup
# Letâ€™s create the environment for our simulation. This setup covers the creation of (celestial) bodies, vehicle(s), and environment interfaces.
# 
# ### Create the bodies
# Bodies can be created by making a list of strings with the bodies that is to be included in the simulation.
# 
# The default body settings (such as atmosphere, body shape, rotation model) are taken from `SPICE`.
# 
# These settings can be adjusted. Please refere to the [Available Environment Models](https://tudat-space.readthedocs.io/en/latest/_src_user_guide/state_propagation/environment_setup/create_models/available.html#available-environment-models) in the user guide for more details.
# 
# Finally, the system of bodies is created using the settings. This system of bodies is stored into the variable `bodies`.


# Define string names for bodies to be created from default.
bodies_to_create = ["Sun", "Earth", "Moon", "Mars", "Venus"]

# Use "Earth"/"J2000" as global frame origin and orientation.
global_frame_origin = "Earth"
global_frame_orientation = "J2000"

# Create default body settings, usually from `spice`.
body_settings = environment_setup.get_default_body_settings(
    bodies_to_create,
    global_frame_origin,
    global_frame_orientation)

# Create system of selected celestial bodies
bodies = environment_setup.create_system_of_bodies(body_settings)


# ### Create the vehicle
# Let's now create the 400kg satellite for which the perturbed orbit around Earth will be propagated.


# Create vehicle objects.
bodies.create_empty_body("Delfi-C3")

bodies.get("Delfi-C3").mass = 2.2

# To account for the aerodynamic of the satellite, let's add an aerodynamic interface and add it to the environment setup, taking the followings into account:
# - A constant drag coefficient of 1.2.
# - A reference area of 0.035m$^2$.
# - No sideslip or lift coefficient (equal to 0).
# - No moment coefficient.

# Create aerodynamic coefficient interface settings, and add to vehicle
reference_area = 0.011  # Average projection area of a 3U CubeSat
drag_coefficient = 1.5


# To account for the pressure of the solar radiation on the satellite, let's add another interface. This takes a radiation pressure coefficient of 1.2, and a radiation area of 4m$^2$. This interface also accounts for the variation in pressure cause by the shadow of Earth.


# Create radiation pressure settings, and add to vehicle
reference_area_radiation = 0.011  # Average projection area of a 3U CubeSat
radiation_pressure_coefficient = 1.2
occulting_bodies_dict = dict()
occulting_bodies_dict[ "Sun" ] = [ "Earth" ]
vehicle_target_settings = environment_setup.radiation_pressure.cannonball_radiation_target(
    reference_area_radiation, radiation_pressure_coefficient, occulting_bodies_dict )
environment_setup.add_radiation_pressure_target_model(
    bodies, "Delfi-C3", vehicle_target_settings)


# ## Propagation setup
# Now that the environment is created, the propagation setup is defined.
# 
# First, the bodies to be propagated and the central bodies will be defined.
# Central bodies are the bodies with respect to which the state of the respective propagated bodies is defined.

# Define bodies that are propagated
bodies_to_propagate = ["Delfi-C3"]

# Define central bodies of propagation
central_bodies = ["Earth"]

# ### Create the acceleration model
# First off, the acceleration settings that act on `Delfi-C3` are to be defined.
# In this case, these consist in the followings:
# - Graviational acceleration of Earth modeled as Spherical Harmonics, taken up to a degree and order 5.
# - Gravitational acceleration of the Sun, the Moon, Mars, and Venus, modeled as a Point Mass.
# - Aerodynamic acceleration caused by the atmosphere of the Earth (using the aerodynamic interface defined earlier).
# - Radiation pressure acceleration caused by the Sun (using the radiation interface defined earlier).
# 
# The acceleration settings defined are then applied to `Delfi-C3` in a dictionary.
# 
# This dictionary is finally input to the propagation setup to create the acceleration models.

# Define accelerations acting on Delfi-C3 by Sun and Earth.
accelerations_settings_delfi_c3 = dict(
    Sun=[
        propagation_setup.acceleration.radiation_pressure(),
        propagation_setup.acceleration.point_mass_gravity()
    ],
    Earth=[
        propagation_setup.acceleration.spherical_harmonic_gravity(5, 5),
        propagation_setup.acceleration.aerodynamic()
    ],
    Moon=[
        propagation_setup.acceleration.point_mass_gravity()
    ],
    Mars=[
        propagation_setup.acceleration.point_mass_gravity()
    ],
    Venus=[
        propagation_setup.acceleration.point_mass_gravity()
    ]
)

# Create global accelerations settings dictionary.
acceleration_settings = {"Delfi-C3": accelerations_settings_delfi_c3}

# Create acceleration models.

# ### Define the initial state
# The initial state of the vehicle that will be propagated is now defined. 
# 
# This initial state always has to be provided as a cartesian state, in the form of a list with the first three elements reprensenting the initial position, and the three remaining elements representing the initial velocity.
# 
# Within this example, we will retrieve the initial state of Delfi-C3 using its Two-Line-Elements (TLE) the date of its launch (April the 28th, 2008). The TLE strings are obtained from [space-track.org](https://www.space-track.org).

# Set initial conditions for the satellite that will be
# propagated in this simulation. The initial conditions are given in
# Keplerian elements and later on converted to Cartesian elements
earth_gravitational_parameter = bodies.get("Earth").gravitational_parameter
initial_state = element_conversion.keplerian_to_cartesian_elementwise(
    gravitational_parameter=earth_gravitational_parameter,
    semi_major_axis= 7002.990555879878e3,
    eccentricity= 0.001126,
    inclination=np.deg2rad(97.3369),
    argument_of_periapsis=np.deg2rad(53.4348),
    longitude_of_ascending_node=np.deg2rad(272.4752),
    true_anomaly=element_conversion.mean_to_true_anomaly(eccentricity=0.001126, mean_anomaly=np.deg2rad(306.7920)),
)


# ### Define dependent variables to save
# In this example, we are interested in saving not only the propagated state of the satellite over time, but also a set of so-called dependent variables, that are to be computed (or extracted and saved) at each integration step.
# 
# [This page](https://tudatpy.readthedocs.io/en/latest/dependent_variable.html) of the tudatpy API website provides a detailled explanation of all the dependent variables that are available.

# Define list of dependent variables to save
dependent_variables_to_save = [
    propagation_setup.dependent_variable.total_acceleration("Delfi-C3"),
    propagation_setup.dependent_variable.keplerian_state("Delfi-C3", "Earth"),
    propagation_setup.dependent_variable.latitude("Delfi-C3", "Earth"),
    propagation_setup.dependent_variable.longitude("Delfi-C3", "Earth"),
    propagation_setup.dependent_variable.single_acceleration_norm(
        propagation_setup.acceleration.point_mass_gravity_type, "Delfi-C3", "Sun"
    ),
    propagation_setup.dependent_variable.single_acceleration_norm(
        propagation_setup.acceleration.point_mass_gravity_type, "Delfi-C3", "Moon"
    ),
    propagation_setup.dependent_variable.single_acceleration_norm(
        propagation_setup.acceleration.point_mass_gravity_type, "Delfi-C3", "Mars"
    ),
    propagation_setup.dependent_variable.single_acceleration_norm(
        propagation_setup.acceleration.point_mass_gravity_type, "Delfi-C3", "Venus"
    ),
    propagation_setup.dependent_variable.single_acceleration_norm(
        propagation_setup.acceleration.spherical_harmonic_gravity_type, "Delfi-C3", "Earth"
    ),
    propagation_setup.dependent_variable.single_acceleration_norm(
        propagation_setup.acceleration.aerodynamic_type, "Delfi-C3", "Earth"
    ),
    propagation_setup.dependent_variable.single_acceleration_norm(
        propagation_setup.acceleration.cannonball_radiation_pressure_type, "Delfi-C3", "Sun"
    ),
    propagation_setup.dependent_variable.altitude("Delfi-C3", "Earth"),
]

print(propagation_setup.dependent_variable.PropagationDependentVariables(1))
# ### Create the propagator settings
# The propagator is finally setup.
# 
# First, a termination condition is defined so that the propagation will stop when the end epochs that was defined is reached.
# 
# Subsequently, the integrator settings are defined using a RK4 integrator with the fixed step size of 10 seconds.
# 
# Then, the translational propagator settings are defined. These are used to simulate the orbit of `Delfi-C3` around Earth.


# Create termination settings
#termination_condition = propagation_setup.propagator.time_termination(simulation_end_epoch)
termination_settings_list = [propagation_setup.propagator.time_termination(simulation_end_epoch), propagation_setup.propagator.dependent_variable_termination(
  dependent_variable_settings = propagation_setup.dependent_variable.altitude( "Delfi-C3", "Earth" ),
  limit_value = 100.0E3,
  use_as_lower_limit = True)]
termination_condition = propagation_setup.propagator.hybrid_termination(termination_settings_list, fulfill_single_condition = True)

# Create numerical integrator settings
fixed_step_size = 200.0
# integrator_settings = propagation_setup.integrator.runge_kutta_4(fixed_step_size)
# integrator_settings = propagation_setup.integrator.adams_bashforth_moulton(fixed_step_size, 5.0, 150, minimum_order=6, maximum_order=11)
integrator_settings = propagation_setup.integrator.bulirsch_stoer_variable_step(initial_time_step=fixed_step_size,extrapolation_sequence = propagation_setup.integrator.deufelhard_sequence, maximum_number_of_steps=7, 
                                                                                step_size_control_settings =propagation_setup.integrator.step_size_control_elementwise_scalar_tolerance(1.0E-10, 1.0E-10, minimum_factor_increase=0.05),
                                                                                step_size_validation_settings =propagation_setup.integrator.step_size_validation(0.1, 10000.0),
                                                                                assess_termination_on_minor_steps = False)


# processing_settings = propagation_setup.propagator.SingleArcPropagatorProcessingSettings()



# Create propagation settings

#print(propagator_settings.print_settings)


# ## Propagate the orbit
# The orbit is now ready to be propagated.
# 
# This is done by calling the `create_dynamics_simulator()` function of the `numerical_simulation module`.
# This function requires the `bodies` and `propagator_settings` that have all been defined earlier.
# 
# After this, the history of the propagated state over time, containing both the position and velocity history, is extracted.
# This history, taking the form of a dictionary, is then converted to an array containing 7 columns:
# - Column 0: Time history, in seconds since J2000.
# - Columns 1 to 3: Position history, in meters, in the frame that was specified in the `body_settings`.
# - Columns 4 to 6: Velocity history, in meters per second, in the frame that was specified in the `body_settings`.
# 
# The same is done with the dependent variable history. The column indexes corresponding to a given dependent variable in the `dep_vars` variable are printed when the simulation is run, when `create_dynamics_simulator()` is called.
# Do mind that converting to an ndarray using the `result2array()` utility will shift these indexes, since the first column (index 0) will then be the times.

DC = []
FA= []
for i in range(5):
    drag_coefficient = drag_coefficient + 0.5

    aero_coefficient_settings = environment_setup.aerodynamic_coefficients.constant(
    reference_area, [drag_coefficient, 0, 0]
    )
    environment_setup.add_aerodynamic_coefficient_interface(
    bodies, "Delfi-C3", aero_coefficient_settings)

    acceleration_models = propagation_setup.create_acceleration_models(
    bodies,
    acceleration_settings,
    bodies_to_propagate,
    central_bodies)
    propagator_settings = propagation_setup.propagator.translational(
        central_bodies,
        acceleration_models,
        bodies_to_propagate,
        initial_state,
        simulation_start_epoch,
        integrator_settings,
        termination_condition,
        output_variables=dependent_variables_to_save,
    )
    propagator_settings.print_settings.print_dependent_variable_indices = True
    propagator_settings.print_settings.print_state_indices = True
    # propagator_settings.print_settings.results_print_frequency_in_seconds = 0.5e7
    propagator_settings.print_settings.results_print_frequency_in_steps =100000

   
    DC.append(drag_coefficient)

# Create simulation object and propagate the dynamics
    dynamics_simulator = numerical_simulation.create_dynamics_simulator(
        bodies, propagator_settings)


# Extract the resulting state and depedent variable history and convert it to an ndarray
    states = dynamics_simulator.state_history
    states_array = result2array(states)
    dep_vars = dynamics_simulator.dependent_variable_history
    dep_vars_array = result2array(dep_vars)

    Final_altitude = dep_vars_array[-1,19]
    FA.append(Final_altitude)

print(DC)
print(FA)





# ## Post-process the propagation results
# The results of the propagation are then processed to a more user-friendly form.
# 
# ### Total acceleration over time
# Let's first plot the total acceleration on the satellite over time. This can be done by taking the norm of the first three columns of the dependent variable list.


# Plot total acceleration as function of time
start_time=(time_conversion.calendar_date_to_julian_day(datetime.datetime(2022, 9, 6, 0, 27, 0, 970272))-time_conversion.calendar_date_to_julian_day(datetime.datetime(2000, 1, 1, 0, 0, 0, 0)))
print(dep_vars_array[:,0]/(3600*24))
time_days = dep_vars_array[:,0]/(3600*24) - start_time
total_acceleration_norm = np.linalg.norm(dep_vars_array[:,1:4], axis=1)
"""plt.figure(figsize=(9, 5))
plt.title("Total acceleration norm on Delfi-C3 over the course of propagation.")
plt.plot(time_days, total_acceleration_norm)
plt.xlabel('Time [days]')
plt.ylabel('Total Acceleration [m/s$^2$]')
plt.xlim([min(time_days), max(time_days)])
plt.grid()
plt.tight_layout()
plt.show()"""

#print(dep_vars_array[0,:])
# altitude over time
altitude = dep_vars_array[:,19]
dates = [time_conversion.julian_day_to_calendar_date(start_date.julian_day()) + datetime.timedelta(days=day) for day in time_days]
"""plt.figure(figsize=(9, 5))
plt.title("Altitude of Delfi-C3 over the course of propagation.")
plt.plot(dates, altitude)
plt.gcf().autofmt_xdate()
plt.xlabel('Time [days]')
plt.ylabel('Altitude [m]')
plt.xlim([min(dates), max(dates)])
plt.grid()
plt.tight_layout()
plt.show()
plt.savefig('altitude.png')"""


plt.figure(figsize=(9, 5))
plt.title("DC vs FA.")
plt.plot(DC, FA)
plt.xlabel('DC')
plt.ylabel('Altitude [m]')
plt.grid()
plt.tight_layout()
plt.show()
plt.savefig('altitude vs DC.png')


# ### Ground track
# Let's then plot the ground track of the satellite in its first 3 hours. This makes use of the latitude and longitude dependent variables.


# Plot ground track for a period of 3 hours
latitude = dep_vars_array[:,10]
longitude = dep_vars_array[:,11]
hours = 3
subset = int(len(time_days) / 24 * hours)
latitude = np.rad2deg(latitude[0: subset])
longitude = np.rad2deg(longitude[0: subset])
"""plt.figure(figsize=(9, 5))
plt.title("3 hour ground track of Delfi-C3")
plt.scatter(longitude, latitude, s=1)
plt.xlabel('Longitude [deg]')
plt.ylabel('Latitude [deg]')
plt.xlim([min(longitude), max(longitude)])
plt.yticks(np.arange(-90, 91, step=45))
plt.grid()
plt.tight_layout()
plt.show()
plt.savefig('ground track.png')"""

# ### Kepler elements over time
# Let's now plot each of the 6 Kepler element as a function of time, also as saved in the dependent variables.


# Plot Kepler elements as a function of time
"""kepler_elements = dep_vars_array[:,4:10]
fig, ((ax1, ax2), (ax3, ax4), (ax5, ax6)) = plt.subplots(3, 2, figsize=(9, 12))
fig.suptitle('Evolution of Kepler elements over the course of the propagation.')

# Semi-major Axis
semi_major_axis = kepler_elements[:,0] / 1e3
ax1.plot(time_days, semi_major_axis, linewidth=1)
ax1.set_ylabel('Semi-major axis [km]')

# Eccentricity
eccentricity = kepler_elements[:,1]
ax2.plot(time_days, eccentricity, linewidth=1)
ax2.set_ylabel('Eccentricity [-]')

# Inclination
inclination = np.rad2deg(kepler_elements[:,2])
ax3.plot(time_days, inclination, linewidth=1)
ax3.set_ylabel('Inclination [deg]')

# Argument of Periapsis
argument_of_periapsis = np.rad2deg(kepler_elements[:,3])
ax4.plot(time_days, argument_of_periapsis, linewidth=1)
ax4.set_ylabel('Argument of Periapsis [deg]')

# Right Ascension of the Ascending Node
raan = np.rad2deg(kepler_elements[:,4])
ax5.plot(time_days, raan, linewidth=1)
ax5.set_ylabel('RAAN [deg]')

# True Anomaly
true_anomaly = np.rad2deg(kepler_elements[:,5])
ax6.scatter(time_days, true_anomaly, s=1, linewidths=1)
ax6.set_ylabel('True Anomaly [deg]')
ax6.set_yticks(np.arange(0, 361, step=60))

for ax in fig.get_axes():
    ax.set_xlabel('Time [days]')
    ax.set_xlim([min(time_days), max(time_days)])
    ax.grid()
plt.tight_layout()
plt.show()
plt.savefig('test.png')"""


# ### Accelerations over time
# Finally, let's plot and compare each of the included accelerations.

"""plt.figure(figsize=(9, 5))

# Point Mass Gravity Acceleration Sun
acceleration_norm_pm_sun = dep_vars_array[:,12]
plt.plot(time_days, acceleration_norm_pm_sun, label='PM Sun', linewidth=1)

# Point Mass Gravity Acceleration Moon
acceleration_norm_pm_moon = dep_vars_array[:,13]
plt.plot(time_days, acceleration_norm_pm_moon, label='PM Moon', linewidth=1)

# Point Mass Gravity Acceleration Mars
acceleration_norm_pm_mars = dep_vars_array[:,14]
plt.plot(time_days, acceleration_norm_pm_mars, label='PM Mars', linewidth=1)

# Point Mass Gravity Acceleration Venus
acceleration_norm_pm_venus = dep_vars_array[:,15]
plt.plot(time_days, acceleration_norm_pm_venus, label='PM Venus', linewidth=1)

# Spherical Harmonic Gravity Acceleration Earth
acceleration_norm_sh_earth = dep_vars_array[:,16]
plt.plot(time_days, acceleration_norm_sh_earth, label='SH Earth', linewidth=1)

# Aerodynamic Acceleration Earth
acceleration_norm_aero_earth = dep_vars_array[:,17]
plt.plot(time_days, acceleration_norm_aero_earth, label='Aerodynamic Earth', linewidth=1)

# Cannonball Radiation Pressure Acceleration Sun
acceleration_norm_rp_sun = dep_vars_array[:,18]
plt.plot(time_days, acceleration_norm_rp_sun, label='Radiation Pressure Sun', linewidth=1)

plt.xlim([min(time_days), max(time_days)])
plt.xlabel('Time [days]')
plt.ylabel('Acceleration Norm [m/s$^2$]')

plt.legend(bbox_to_anchor=(1.005, 1))
plt.suptitle("Accelerations norms on Delfi-C3, distinguished by type and origin, over the course of propagation.")
plt.yscale('log')
plt.grid()
plt.tight_layout()
plt.show()
plt.savefig('test2.png')"""